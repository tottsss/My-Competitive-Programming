// Advanced Techniques(Searching)
 Binary Search
 Two pointers
 Sliding Window  
 Meet in the middle
 Coordinate Compress
 Divide and Conquer
 Merge Sort
 Ternary Search
 Random algorithms
 
 
// Data Structures
 Segment Tree or 2D
 Sparse, Persistent Segment tree
 Algorithm Mo + Sqrt Decomposition
 Sparse Table
 Fenwick tree
 Treap
 Ordered_set (C++ data structure)
 Unordered_Map
 
// Dynamic Programming
 2D Dynamic programming 
 Prefix SUM  and Suffix SUM
 Bitmask DP
 Knapsack 
 DP substring
 Graph + DP
 
// String Algorithms
 Z algorithm
 KMP
 Trie
 Suffix array
 
// Graph
 simple Graph
 DFS 
 Necessary Roads and Cities
 Topological Sort
 Strongly connected components)
 MST
 BFS 
 Shortest path - (dijkstra, ford Bellmana)
 DSU
 Binary Search + Graph
 
// Tree algorithms
 Heavy light Decomposition 
 Centroid Decomposition
 Lowest Common Ancestor
 Eular path
 
// Brute Force
 Recursion
 Bitmask
 
 
 
 
/*
  0. Enough array size? Enough array size? Enough array size? Integer overflow?
  
  1. Think TWICE, Code ONCE!
  Are there any counterexamples to your algo?
    
  2. Be careful about the BOUNDARIES!
  N=1? P=1? Something about 0?
    
  3. Do not make STUPID MISTAKES!
  Time complexity? Memory usage? Precision error?
  
  4. Write Examples on your whiteboard and find the mistakes and counterexamples
*/

/*

it never gets easier, you just get better.
*/



/* stuff you should look for
	* int overflow, array bounds
	* special cases (n=1?)
	* do smth instead of nothing and stay organized
	* WRITE STUFF DOWN
	* DON'T GET STUCK ON ONE APPROACH
*/
/*


*/